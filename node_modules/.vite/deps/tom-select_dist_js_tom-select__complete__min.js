import {
  __commonJS
} from "./chunk-UXIASGQL.js";

// node_modules/tom-select/dist/js/tom-select.complete.min.js
var require_tom_select_complete_min = __commonJS({
  "node_modules/tom-select/dist/js/tom-select.complete.min.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).TomSelect = t();
    }(exports, function() {
      "use strict";
      function e(e2, t2) {
        e2.split(/\s+/).forEach((e3) => {
          t2(e3);
        });
      }
      class t {
        constructor() {
          this._events = void 0, this._events = {};
        }
        on(t2, i2) {
          e(t2, (e2) => {
            const t3 = this._events[e2] || [];
            t3.push(i2), this._events[e2] = t3;
          });
        }
        off(t2, i2) {
          var s2 = arguments.length;
          0 !== s2 ? e(t2, (e2) => {
            if (1 === s2)
              return void delete this._events[e2];
            const t3 = this._events[e2];
            void 0 !== t3 && (t3.splice(t3.indexOf(i2), 1), this._events[e2] = t3);
          }) : this._events = {};
        }
        trigger(t2, ...i2) {
          var s2 = this;
          e(t2, (e2) => {
            const t3 = s2._events[e2];
            void 0 !== t3 && t3.forEach((e3) => {
              e3.apply(s2, i2);
            });
          });
        }
      }
      const i = (e2) => (e2 = e2.filter(Boolean)).length < 2 ? e2[0] || "" : 1 == l(e2) ? "[" + e2.join("") + "]" : "(?:" + e2.join("|") + ")", s = (e2) => {
        if (!o(e2))
          return e2.join("");
        let t2 = "", i2 = 0;
        const s2 = () => {
          i2 > 1 && (t2 += "{" + i2 + "}");
        };
        return e2.forEach((n2, o2) => {
          n2 !== e2[o2 - 1] ? (s2(), t2 += n2, i2 = 1) : i2++;
        }), s2(), t2;
      }, n = (e2) => {
        let t2 = c(e2);
        return i(t2);
      }, o = (e2) => new Set(e2).size !== e2.length, r = (e2) => (e2 + "").replace(/([\$\(\)\*\+\.\?\[\]\^\{\|\}\\])/gu, "\\$1"), l = (e2) => e2.reduce((e3, t2) => Math.max(e3, a(t2)), 0), a = (e2) => c(e2).length, c = (e2) => Array.from(e2), d = (e2) => {
        if (1 === e2.length)
          return [[e2]];
        let t2 = [];
        const i2 = e2.substring(1);
        return d(i2).forEach(function(i3) {
          let s2 = i3.slice(0);
          s2[0] = e2.charAt(0) + s2[0], t2.push(s2), s2 = i3.slice(0), s2.unshift(e2.charAt(0)), t2.push(s2);
        }), t2;
      }, u = [[0, 65535]];
      let p, h;
      const g = {}, f = { "/": "⁄∕", 0: "߀", a: "ⱥɐɑ", aa: "ꜳ", ae: "æǽǣ", ao: "ꜵ", au: "ꜷ", av: "ꜹꜻ", ay: "ꜽ", b: "ƀɓƃ", c: "ꜿƈȼↄ", d: "đɗɖᴅƌꮷԁɦ", e: "ɛǝᴇɇ", f: "ꝼƒ", g: "ǥɠꞡᵹꝿɢ", h: "ħⱨⱶɥ", i: "ɨı", j: "ɉȷ", k: "ƙⱪꝁꝃꝅꞣ", l: "łƚɫⱡꝉꝇꞁɭ", m: "ɱɯϻ", n: "ꞥƞɲꞑᴎлԉ", o: "øǿɔɵꝋꝍᴑ", oe: "œ", oi: "ƣ", oo: "ꝏ", ou: "ȣ", p: "ƥᵽꝑꝓꝕρ", q: "ꝗꝙɋ", r: "ɍɽꝛꞧꞃ", s: "ßȿꞩꞅʂ", t: "ŧƭʈⱦꞇ", th: "þ", tz: "ꜩ", u: "ʉ", v: "ʋꝟʌ", vy: "ꝡ", w: "ⱳ", y: "ƴɏỿ", z: "ƶȥɀⱬꝣ", hv: "ƕ" };
      for (let e2 in f) {
        let t2 = f[e2] || "";
        for (let i2 = 0; i2 < t2.length; i2++) {
          let s2 = t2.substring(i2, i2 + 1);
          g[s2] = e2;
        }
      }
      const v = new RegExp(Object.keys(g).join("|") + "|[̀-ͯ·ʾʼ]", "gu"), m = (e2, t2 = "NFKD") => e2.normalize(t2), y = (e2) => c(e2).reduce((e3, t2) => e3 + O(t2), ""), O = (e2) => (e2 = m(e2).toLowerCase().replace(v, (e3) => g[e3] || ""), m(e2, "NFC"));
      const b = (e2) => {
        const t2 = {}, i2 = (e3, i3) => {
          const s2 = t2[e3] || /* @__PURE__ */ new Set(), o2 = new RegExp("^" + n(s2) + "$", "iu");
          i3.match(o2) || (s2.add(r(i3)), t2[e3] = s2);
        };
        for (let t3 of function* (e3) {
          for (const [t4, i3] of e3)
            for (let e4 = t4; e4 <= i3; e4++) {
              let t5 = String.fromCharCode(e4), i4 = y(t5);
              i4 != t5.toLowerCase() && (i4.length > 3 || 0 != i4.length && (yield { folded: i4, composed: t5, code_point: e4 }));
            }
        }(e2))
          i2(t3.folded, t3.folded), i2(t3.folded, t3.composed);
        return t2;
      }, w = (e2) => {
        const t2 = b(e2), s2 = {};
        let o2 = [];
        for (let e3 in t2) {
          let i2 = t2[e3];
          i2 && (s2[e3] = n(i2)), e3.length > 1 && o2.push(r(e3));
        }
        o2.sort((e3, t3) => t3.length - e3.length);
        const l2 = i(o2);
        return h = new RegExp("^" + l2, "u"), s2;
      }, _ = (e2, t2 = 1) => (t2 = Math.max(t2, e2.length - 1), i(d(e2).map((e3) => ((e4, t3 = 1) => {
        let i2 = 0;
        return e4 = e4.map((e5) => (p[e5] && (i2 += e5.length), p[e5] || e5)), i2 >= t3 ? s(e4) : "";
      })(e3, t2)))), C = (e2, t2 = true) => {
        let n2 = e2.length > 1 ? 1 : 0;
        return i(e2.map((e3) => {
          let i2 = [];
          const o2 = t2 ? e3.length() : e3.length() - 1;
          for (let t3 = 0; t3 < o2; t3++)
            i2.push(_(e3.substrs[t3] || "", n2));
          return s(i2);
        }));
      }, S = (e2, t2) => {
        for (const i2 of t2) {
          if (i2.start != e2.start || i2.end != e2.end)
            continue;
          if (i2.substrs.join("") !== e2.substrs.join(""))
            continue;
          let t3 = e2.parts;
          const s2 = (e3) => {
            for (const i3 of t3) {
              if (i3.start === e3.start && i3.substr === e3.substr)
                return false;
              if (1 != e3.length && 1 != i3.length) {
                if (e3.start < i3.start && e3.end > i3.start)
                  return true;
                if (i3.start < e3.start && i3.end > e3.start)
                  return true;
              }
            }
            return false;
          };
          if (!(i2.parts.filter(s2).length > 0))
            return true;
        }
        return false;
      };
      class I {
        constructor() {
          this.parts = [], this.substrs = [], this.start = 0, this.end = 0;
        }
        add(e2) {
          e2 && (this.parts.push(e2), this.substrs.push(e2.substr), this.start = Math.min(e2.start, this.start), this.end = Math.max(e2.end, this.end));
        }
        last() {
          return this.parts[this.parts.length - 1];
        }
        length() {
          return this.parts.length;
        }
        clone(e2, t2) {
          let i2 = new I(), s2 = JSON.parse(JSON.stringify(this.parts)), n2 = s2.pop();
          for (const e3 of s2)
            i2.add(e3);
          let o2 = t2.substr.substring(0, e2 - n2.start), r2 = o2.length;
          return i2.add({ start: n2.start, end: n2.start + r2, length: r2, substr: o2 }), i2;
        }
      }
      const A = (e2) => {
        var t2;
        void 0 === p && (p = w(t2 || u)), e2 = y(e2);
        let i2 = "", s2 = [new I()];
        for (let t3 = 0; t3 < e2.length; t3++) {
          let n2 = e2.substring(t3).match(h);
          const o2 = e2.substring(t3, t3 + 1), r2 = n2 ? n2[0] : null;
          let l2 = [], a2 = /* @__PURE__ */ new Set();
          for (const e3 of s2) {
            const i3 = e3.last();
            if (!i3 || 1 == i3.length || i3.end <= t3)
              if (r2) {
                const i4 = r2.length;
                e3.add({ start: t3, end: t3 + i4, length: i4, substr: r2 }), a2.add("1");
              } else
                e3.add({ start: t3, end: t3 + 1, length: 1, substr: o2 }), a2.add("2");
            else if (r2) {
              let s3 = e3.clone(t3, i3);
              const n3 = r2.length;
              s3.add({ start: t3, end: t3 + n3, length: n3, substr: r2 }), l2.push(s3);
            } else
              a2.add("3");
          }
          if (l2.length > 0) {
            l2 = l2.sort((e3, t4) => e3.length() - t4.length());
            for (let e3 of l2)
              S(e3, s2) || s2.push(e3);
          } else if (t3 > 0 && 1 == a2.size && !a2.has("3")) {
            i2 += C(s2, false);
            let e3 = new I();
            const t4 = s2[0];
            t4 && e3.add(t4.last()), s2 = [e3];
          }
        }
        return i2 += C(s2, true), i2;
      }, x = (e2, t2) => {
        if (e2)
          return e2[t2];
      }, k = (e2, t2) => {
        if (e2) {
          for (var i2, s2 = t2.split("."); (i2 = s2.shift()) && (e2 = e2[i2]); )
            ;
          return e2;
        }
      }, F = (e2, t2, i2) => {
        var s2, n2;
        return e2 ? (e2 += "", null == t2.regex || -1 === (n2 = e2.search(t2.regex)) ? 0 : (s2 = t2.string.length / e2.length, 0 === n2 && (s2 += 0.5), s2 * i2)) : 0;
      }, L = (e2, t2) => {
        var i2 = e2[t2];
        if ("function" == typeof i2)
          return i2;
        i2 && !Array.isArray(i2) && (e2[t2] = [i2]);
      }, E = (e2, t2) => {
        if (Array.isArray(e2))
          e2.forEach(t2);
        else
          for (var i2 in e2)
            e2.hasOwnProperty(i2) && t2(e2[i2], i2);
      }, T = (e2, t2) => "number" == typeof e2 && "number" == typeof t2 ? e2 > t2 ? 1 : e2 < t2 ? -1 : 0 : (e2 = y(e2 + "").toLowerCase()) > (t2 = y(t2 + "").toLowerCase()) ? 1 : t2 > e2 ? -1 : 0;
      class P {
        constructor(e2, t2) {
          this.items = void 0, this.settings = void 0, this.items = e2, this.settings = t2 || { diacritics: true };
        }
        tokenize(e2, t2, i2) {
          if (!e2 || !e2.length)
            return [];
          const s2 = [], n2 = e2.split(/\s+/);
          var o2;
          return i2 && (o2 = new RegExp("^(" + Object.keys(i2).map(r).join("|") + "):(.*)$")), n2.forEach((e3) => {
            let i3, n3 = null, l2 = null;
            o2 && (i3 = e3.match(o2)) && (n3 = i3[1], e3 = i3[2]), e3.length > 0 && (l2 = this.settings.diacritics ? A(e3) || null : r(e3), l2 && t2 && (l2 = "\\b" + l2)), s2.push({ string: e3, regex: l2 ? new RegExp(l2, "iu") : null, field: n3 });
          }), s2;
        }
        getScoreFunction(e2, t2) {
          var i2 = this.prepareSearch(e2, t2);
          return this._getScoreFunction(i2);
        }
        _getScoreFunction(e2) {
          const t2 = e2.tokens, i2 = t2.length;
          if (!i2)
            return function() {
              return 0;
            };
          const s2 = e2.options.fields, n2 = e2.weights, o2 = s2.length, r2 = e2.getAttrFn;
          if (!o2)
            return function() {
              return 1;
            };
          const l2 = 1 === o2 ? function(e3, t3) {
            const i3 = s2[0].field;
            return F(r2(t3, i3), e3, n2[i3] || 1);
          } : function(e3, t3) {
            var i3 = 0;
            if (e3.field) {
              const s3 = r2(t3, e3.field);
              !e3.regex && s3 ? i3 += 1 / o2 : i3 += F(s3, e3, 1);
            } else
              E(n2, (s3, n3) => {
                i3 += F(r2(t3, n3), e3, s3);
              });
            return i3 / o2;
          };
          return 1 === i2 ? function(e3) {
            return l2(t2[0], e3);
          } : "and" === e2.options.conjunction ? function(e3) {
            var s3, n3 = 0;
            for (let i3 of t2) {
              if ((s3 = l2(i3, e3)) <= 0)
                return 0;
              n3 += s3;
            }
            return n3 / i2;
          } : function(e3) {
            var s3 = 0;
            return E(t2, (t3) => {
              s3 += l2(t3, e3);
            }), s3 / i2;
          };
        }
        getSortFunction(e2, t2) {
          var i2 = this.prepareSearch(e2, t2);
          return this._getSortFunction(i2);
        }
        _getSortFunction(e2) {
          var t2, i2 = [];
          const s2 = this, n2 = e2.options, o2 = !e2.query && n2.sort_empty ? n2.sort_empty : n2.sort;
          if ("function" == typeof o2)
            return o2.bind(this);
          const r2 = function(t3, i3) {
            return "$score" === t3 ? i3.score : e2.getAttrFn(s2.items[i3.id], t3);
          };
          if (o2)
            for (let t3 of o2)
              (e2.query || "$score" !== t3.field) && i2.push(t3);
          if (e2.query) {
            t2 = true;
            for (let e3 of i2)
              if ("$score" === e3.field) {
                t2 = false;
                break;
              }
            t2 && i2.unshift({ field: "$score", direction: "desc" });
          } else
            i2 = i2.filter((e3) => "$score" !== e3.field);
          return i2.length ? function(e3, t3) {
            var s3, n3;
            for (let o3 of i2) {
              if (n3 = o3.field, s3 = ("desc" === o3.direction ? -1 : 1) * T(r2(n3, e3), r2(n3, t3)))
                return s3;
            }
            return 0;
          } : null;
        }
        prepareSearch(e2, t2) {
          const i2 = {};
          var s2 = Object.assign({}, t2);
          if (L(s2, "sort"), L(s2, "sort_empty"), s2.fields) {
            L(s2, "fields");
            const e3 = [];
            s2.fields.forEach((t3) => {
              "string" == typeof t3 && (t3 = { field: t3, weight: 1 }), e3.push(t3), i2[t3.field] = "weight" in t3 ? t3.weight : 1;
            }), s2.fields = e3;
          }
          return { options: s2, query: e2.toLowerCase().trim(), tokens: this.tokenize(e2, s2.respect_word_boundaries, i2), total: 0, items: [], weights: i2, getAttrFn: s2.nesting ? k : x };
        }
        search(e2, t2) {
          var i2, s2, n2 = this;
          s2 = this.prepareSearch(e2, t2), t2 = s2.options, e2 = s2.query;
          const o2 = t2.score || n2._getScoreFunction(s2);
          e2.length ? E(n2.items, (e3, n3) => {
            i2 = o2(e3), (false === t2.filter || i2 > 0) && s2.items.push({ score: i2, id: n3 });
          }) : E(n2.items, (e3, t3) => {
            s2.items.push({ score: 1, id: t3 });
          });
          const r2 = n2._getSortFunction(s2);
          return r2 && s2.items.sort(r2), s2.total = s2.items.length, "number" == typeof t2.limit && (s2.items = s2.items.slice(0, t2.limit)), s2;
        }
      }
      const N = (e2, t2) => {
        if (Array.isArray(e2))
          e2.forEach(t2);
        else
          for (var i2 in e2)
            e2.hasOwnProperty(i2) && t2(e2[i2], i2);
      }, j = (e2) => {
        if (e2.jquery)
          return e2[0];
        if (e2 instanceof HTMLElement)
          return e2;
        if ($(e2)) {
          var t2 = document.createElement("template");
          return t2.innerHTML = e2.trim(), t2.content.firstChild;
        }
        return document.querySelector(e2);
      }, $ = (e2) => "string" == typeof e2 && e2.indexOf("<") > -1, V = (e2, t2) => {
        var i2 = document.createEvent("HTMLEvents");
        i2.initEvent(t2, true, false), e2.dispatchEvent(i2);
      }, q = (e2, t2) => {
        Object.assign(e2.style, t2);
      }, D = (e2, ...t2) => {
        var i2 = H(t2);
        (e2 = M(e2)).map((e3) => {
          i2.map((t3) => {
            e3.classList.add(t3);
          });
        });
      }, R = (e2, ...t2) => {
        var i2 = H(t2);
        (e2 = M(e2)).map((e3) => {
          i2.map((t3) => {
            e3.classList.remove(t3);
          });
        });
      }, H = (e2) => {
        var t2 = [];
        return N(e2, (e3) => {
          "string" == typeof e3 && (e3 = e3.trim().split(/[\11\12\14\15\40]/)), Array.isArray(e3) && (t2 = t2.concat(e3));
        }), t2.filter(Boolean);
      }, M = (e2) => (Array.isArray(e2) || (e2 = [e2]), e2), z = (e2, t2, i2) => {
        if (!i2 || i2.contains(e2))
          for (; e2 && e2.matches; ) {
            if (e2.matches(t2))
              return e2;
            e2 = e2.parentNode;
          }
      }, B = (e2, t2 = 0) => t2 > 0 ? e2[e2.length - 1] : e2[0], K = (e2, t2) => {
        if (!e2)
          return -1;
        t2 = t2 || e2.nodeName;
        for (var i2 = 0; e2 = e2.previousElementSibling; )
          e2.matches(t2) && i2++;
        return i2;
      }, Q = (e2, t2) => {
        N(t2, (t3, i2) => {
          null == t3 ? e2.removeAttribute(i2) : e2.setAttribute(i2, "" + t3);
        });
      }, G = (e2, t2) => {
        e2.parentNode && e2.parentNode.replaceChild(t2, e2);
      }, U = (e2, t2) => {
        if (null === t2)
          return;
        if ("string" == typeof t2) {
          if (!t2.length)
            return;
          t2 = new RegExp(t2, "i");
        }
        const i2 = (e3) => 3 === e3.nodeType ? ((e4) => {
          var i3 = e4.data.match(t2);
          if (i3 && e4.data.length > 0) {
            var s2 = document.createElement("span");
            s2.className = "highlight";
            var n2 = e4.splitText(i3.index);
            n2.splitText(i3[0].length);
            var o2 = n2.cloneNode(true);
            return s2.appendChild(o2), G(n2, s2), 1;
          }
          return 0;
        })(e3) : (((e4) => {
          1 !== e4.nodeType || !e4.childNodes || /(script|style)/i.test(e4.tagName) || "highlight" === e4.className && "SPAN" === e4.tagName || Array.from(e4.childNodes).forEach((e5) => {
            i2(e5);
          });
        })(e3), 0);
        i2(e2);
      }, J = "undefined" != typeof navigator && /Mac/.test(navigator.userAgent) ? "metaKey" : "ctrlKey";
      var W = { options: [], optgroups: [], plugins: [], delimiter: ",", splitOn: null, persist: true, diacritics: true, create: null, createOnBlur: false, createFilter: null, highlight: true, openOnFocus: true, shouldOpen: null, maxOptions: 50, maxItems: null, hideSelected: null, duplicates: false, addPrecedence: false, selectOnTab: false, preload: null, allowEmptyOption: false, refreshThrottle: 300, loadThrottle: 300, loadingClass: "loading", dataAttr: null, optgroupField: "optgroup", valueField: "value", labelField: "text", disabledField: "disabled", optgroupLabelField: "label", optgroupValueField: "value", lockOptgroupOrder: false, sortField: "$order", searchField: ["text"], searchConjunction: "and", mode: null, wrapperClass: "ts-wrapper", controlClass: "ts-control", dropdownClass: "ts-dropdown", dropdownContentClass: "ts-dropdown-content", itemClass: "item", optionClass: "option", dropdownParent: null, controlInput: '<input type="text" autocomplete="off" size="1" />', copyClassesToDropdown: false, placeholder: null, hidePlaceholder: null, shouldLoad: function(e2) {
        return e2.length > 0;
      }, render: {} };
      const X = (e2) => null == e2 ? null : Y(e2), Y = (e2) => "boolean" == typeof e2 ? e2 ? "1" : "0" : e2 + "", Z = (e2) => (e2 + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;"), ee = (e2, t2) => {
        var i2;
        return function(s2, n2) {
          var o2 = this;
          i2 && (o2.loading = Math.max(o2.loading - 1, 0), clearTimeout(i2)), i2 = setTimeout(function() {
            i2 = null, o2.loadedSearches[s2] = true, e2.call(o2, s2, n2);
          }, t2);
        };
      }, te = (e2, t2, i2) => {
        var s2, n2 = e2.trigger, o2 = {};
        for (s2 of (e2.trigger = function() {
          var i3 = arguments[0];
          if (-1 === t2.indexOf(i3))
            return n2.apply(e2, arguments);
          o2[i3] = arguments;
        }, i2.apply(e2, []), e2.trigger = n2, t2))
          s2 in o2 && n2.apply(e2, o2[s2]);
      }, ie = (e2, t2 = false) => {
        e2 && (e2.preventDefault(), t2 && e2.stopPropagation());
      }, se = (e2, t2, i2, s2) => {
        e2.addEventListener(t2, i2, s2);
      }, ne = (e2, t2) => !!t2 && (!!t2[e2] && 1 === (t2.altKey ? 1 : 0) + (t2.ctrlKey ? 1 : 0) + (t2.shiftKey ? 1 : 0) + (t2.metaKey ? 1 : 0)), oe = (e2, t2) => {
        const i2 = e2.getAttribute("id");
        return i2 || (e2.setAttribute("id", t2), t2);
      }, re = (e2) => e2.replace(/[\\"']/g, "\\$&"), le = (e2, t2) => {
        t2 && e2.append(t2);
      };
      function ae(e2, t2) {
        var i2 = Object.assign({}, W, t2), s2 = i2.dataAttr, n2 = i2.labelField, o2 = i2.valueField, r2 = i2.disabledField, l2 = i2.optgroupField, a2 = i2.optgroupLabelField, c2 = i2.optgroupValueField, d2 = e2.tagName.toLowerCase(), u2 = e2.getAttribute("placeholder") || e2.getAttribute("data-placeholder");
        if (!u2 && !i2.allowEmptyOption) {
          let t3 = e2.querySelector('option[value=""]');
          t3 && (u2 = t3.textContent);
        }
        var p2 = { placeholder: u2, options: [], optgroups: [], items: [], maxItems: null };
        return "select" === d2 ? (() => {
          var t3, d3 = p2.options, u3 = {}, h2 = 1;
          let g2 = 0;
          var f2 = (e3) => {
            var t4 = Object.assign({}, e3.dataset), i3 = s2 && t4[s2];
            return "string" == typeof i3 && i3.length && (t4 = Object.assign(t4, JSON.parse(i3))), t4;
          }, v2 = (e3, t4) => {
            var s3 = X(e3.value);
            if (null != s3 && (s3 || i2.allowEmptyOption)) {
              if (u3.hasOwnProperty(s3)) {
                if (t4) {
                  var a3 = u3[s3][l2];
                  a3 ? Array.isArray(a3) ? a3.push(t4) : u3[s3][l2] = [a3, t4] : u3[s3][l2] = t4;
                }
              } else {
                var c3 = f2(e3);
                c3[n2] = c3[n2] || e3.textContent, c3[o2] = c3[o2] || s3, c3[r2] = c3[r2] || e3.disabled, c3[l2] = c3[l2] || t4, c3.$option = e3, c3.$order = c3.$order || ++g2, u3[s3] = c3, d3.push(c3);
              }
              e3.selected && p2.items.push(s3);
            }
          };
          p2.maxItems = e2.hasAttribute("multiple") ? null : 1, N(e2.children, (e3) => {
            var i3, s3, n3;
            "optgroup" === (t3 = e3.tagName.toLowerCase()) ? ((n3 = f2(i3 = e3))[a2] = n3[a2] || i3.getAttribute("label") || "", n3[c2] = n3[c2] || h2++, n3[r2] = n3[r2] || i3.disabled, n3.$order = n3.$order || ++g2, p2.optgroups.push(n3), s3 = n3[c2], N(i3.children, (e4) => {
              v2(e4, s3);
            })) : "option" === t3 && v2(e3);
          });
        })() : (() => {
          const t3 = e2.getAttribute(s2);
          if (t3)
            p2.options = JSON.parse(t3), N(p2.options, (e3) => {
              p2.items.push(e3[o2]);
            });
          else {
            var r3 = e2.value.trim() || "";
            if (!i2.allowEmptyOption && !r3.length)
              return;
            const t4 = r3.split(i2.delimiter);
            N(t4, (e3) => {
              const t5 = {};
              t5[n2] = e3, t5[o2] = e3, p2.options.push(t5);
            }), p2.items = t4;
          }
        })(), Object.assign({}, W, p2, t2);
      }
      var ce = 0;
      class de extends function(e2) {
        return e2.plugins = {}, class extends e2 {
          constructor(...e3) {
            super(...e3), this.plugins = { names: [], settings: {}, requested: {}, loaded: {} };
          }
          static define(t2, i2) {
            e2.plugins[t2] = { name: t2, fn: i2 };
          }
          initializePlugins(e3) {
            var t2, i2;
            const s2 = this, n2 = [];
            if (Array.isArray(e3))
              e3.forEach((e4) => {
                "string" == typeof e4 ? n2.push(e4) : (s2.plugins.settings[e4.name] = e4.options, n2.push(e4.name));
              });
            else if (e3)
              for (t2 in e3)
                e3.hasOwnProperty(t2) && (s2.plugins.settings[t2] = e3[t2], n2.push(t2));
            for (; i2 = n2.shift(); )
              s2.require(i2);
          }
          loadPlugin(t2) {
            var i2 = this, s2 = i2.plugins, n2 = e2.plugins[t2];
            if (!e2.plugins.hasOwnProperty(t2))
              throw new Error('Unable to find "' + t2 + '" plugin');
            s2.requested[t2] = true, s2.loaded[t2] = n2.fn.apply(i2, [i2.plugins.settings[t2] || {}]), s2.names.push(t2);
          }
          require(e3) {
            var t2 = this, i2 = t2.plugins;
            if (!t2.plugins.loaded.hasOwnProperty(e3)) {
              if (i2.requested[e3])
                throw new Error('Plugin has circular dependency ("' + e3 + '")');
              t2.loadPlugin(e3);
            }
            return i2.loaded[e3];
          }
        };
      }(t) {
        constructor(e2, t2) {
          var i2;
          super(), this.control_input = void 0, this.wrapper = void 0, this.dropdown = void 0, this.control = void 0, this.dropdown_content = void 0, this.focus_node = void 0, this.order = 0, this.settings = void 0, this.input = void 0, this.tabIndex = void 0, this.is_select_tag = void 0, this.rtl = void 0, this.inputId = void 0, this._destroy = void 0, this.sifter = void 0, this.isOpen = false, this.isDisabled = false, this.isReadOnly = false, this.isRequired = void 0, this.isInvalid = false, this.isValid = true, this.isLocked = false, this.isFocused = false, this.isInputHidden = false, this.isSetup = false, this.ignoreFocus = false, this.ignoreHover = false, this.hasOptions = false, this.currentResults = void 0, this.lastValue = "", this.caretPos = 0, this.loading = 0, this.loadedSearches = {}, this.activeOption = null, this.activeItems = [], this.optgroups = {}, this.options = {}, this.userOptions = {}, this.items = [], this.refreshTimeout = null, ce++;
          var s2 = j(e2);
          if (s2.tomselect)
            throw new Error("Tom Select already initialized on this element");
          s2.tomselect = this, i2 = (window.getComputedStyle && window.getComputedStyle(s2, null)).getPropertyValue("direction");
          const n2 = ae(s2, t2);
          this.settings = n2, this.input = s2, this.tabIndex = s2.tabIndex || 0, this.is_select_tag = "select" === s2.tagName.toLowerCase(), this.rtl = /rtl/i.test(i2), this.inputId = oe(s2, "tomselect-" + ce), this.isRequired = s2.required, this.sifter = new P(this.options, { diacritics: n2.diacritics }), n2.mode = n2.mode || (1 === n2.maxItems ? "single" : "multi"), "boolean" != typeof n2.hideSelected && (n2.hideSelected = "multi" === n2.mode), "boolean" != typeof n2.hidePlaceholder && (n2.hidePlaceholder = "multi" !== n2.mode);
          var o2 = n2.createFilter;
          "function" != typeof o2 && ("string" == typeof o2 && (o2 = new RegExp(o2)), o2 instanceof RegExp ? n2.createFilter = (e3) => o2.test(e3) : n2.createFilter = (e3) => this.settings.duplicates || !this.options[e3]), this.initializePlugins(n2.plugins), this.setupCallbacks(), this.setupTemplates();
          const r2 = j("<div>"), l2 = j("<div>"), a2 = this._render("dropdown"), c2 = j('<div role="listbox" tabindex="-1">'), d2 = this.input.getAttribute("class") || "", u2 = n2.mode;
          var p2;
          if (D(r2, n2.wrapperClass, d2, u2), D(l2, n2.controlClass), le(r2, l2), D(a2, n2.dropdownClass, u2), n2.copyClassesToDropdown && D(a2, d2), D(c2, n2.dropdownContentClass), le(a2, c2), j(n2.dropdownParent || r2).appendChild(a2), $(n2.controlInput)) {
            p2 = j(n2.controlInput);
            E(["autocorrect", "autocapitalize", "autocomplete", "spellcheck"], (e3) => {
              s2.getAttribute(e3) && Q(p2, { [e3]: s2.getAttribute(e3) });
            }), p2.tabIndex = -1, l2.appendChild(p2), this.focus_node = p2;
          } else
            n2.controlInput ? (p2 = j(n2.controlInput), this.focus_node = p2) : (p2 = j("<input/>"), this.focus_node = l2);
          this.wrapper = r2, this.dropdown = a2, this.dropdown_content = c2, this.control = l2, this.control_input = p2, this.setup();
        }
        setup() {
          const e2 = this, t2 = e2.settings, i2 = e2.control_input, s2 = e2.dropdown, n2 = e2.dropdown_content, o2 = e2.wrapper, l2 = e2.control, a2 = e2.input, c2 = e2.focus_node, d2 = { passive: true }, u2 = e2.inputId + "-ts-dropdown";
          Q(n2, { id: u2 }), Q(c2, { role: "combobox", "aria-haspopup": "listbox", "aria-expanded": "false", "aria-controls": u2 });
          const p2 = oe(c2, e2.inputId + "-ts-control"), h2 = "label[for='" + ((e3) => e3.replace(/['"\\]/g, "\\$&"))(e2.inputId) + "']", g2 = document.querySelector(h2), f2 = e2.focus.bind(e2);
          if (g2) {
            se(g2, "click", f2), Q(g2, { for: p2 });
            const t3 = oe(g2, e2.inputId + "-ts-label");
            Q(c2, { "aria-labelledby": t3 }), Q(n2, { "aria-labelledby": t3 });
          }
          if (o2.style.width = a2.style.width, e2.plugins.names.length) {
            const t3 = "plugin-" + e2.plugins.names.join(" plugin-");
            D([o2, s2], t3);
          }
          (null === t2.maxItems || t2.maxItems > 1) && e2.is_select_tag && Q(a2, { multiple: "multiple" }), t2.placeholder && Q(i2, { placeholder: t2.placeholder }), !t2.splitOn && t2.delimiter && (t2.splitOn = new RegExp("\\s*" + r(t2.delimiter) + "+\\s*")), t2.load && t2.loadThrottle && (t2.load = ee(t2.load, t2.loadThrottle)), se(s2, "mousemove", () => {
            e2.ignoreHover = false;
          }), se(s2, "mouseenter", (t3) => {
            var i3 = z(t3.target, "[data-selectable]", s2);
            i3 && e2.onOptionHover(t3, i3);
          }, { capture: true }), se(s2, "click", (t3) => {
            const i3 = z(t3.target, "[data-selectable]");
            i3 && (e2.onOptionSelect(t3, i3), ie(t3, true));
          }), se(l2, "click", (t3) => {
            var s3 = z(t3.target, "[data-ts-item]", l2);
            s3 && e2.onItemSelect(t3, s3) ? ie(t3, true) : "" == i2.value && (e2.onClick(), ie(t3, true));
          }), se(c2, "keydown", (t3) => e2.onKeyDown(t3)), se(i2, "keypress", (t3) => e2.onKeyPress(t3)), se(i2, "input", (t3) => e2.onInput(t3)), se(c2, "blur", (t3) => e2.onBlur(t3)), se(c2, "focus", (t3) => e2.onFocus(t3)), se(i2, "paste", (t3) => e2.onPaste(t3));
          const v2 = (t3) => {
            const n3 = t3.composedPath()[0];
            if (!o2.contains(n3) && !s2.contains(n3))
              return e2.isFocused && e2.blur(), void e2.inputState();
            n3 == i2 && e2.isOpen ? t3.stopPropagation() : ie(t3, true);
          }, m2 = () => {
            e2.isOpen && e2.positionDropdown();
          };
          se(document, "mousedown", v2), se(window, "scroll", m2, d2), se(window, "resize", m2, d2), this._destroy = () => {
            document.removeEventListener("mousedown", v2), window.removeEventListener("scroll", m2), window.removeEventListener("resize", m2), g2 && g2.removeEventListener("click", f2);
          }, this.revertSettings = { innerHTML: a2.innerHTML, tabIndex: a2.tabIndex }, a2.tabIndex = -1, a2.insertAdjacentElement("afterend", e2.wrapper), e2.sync(false), t2.items = [], delete t2.optgroups, delete t2.options, se(a2, "invalid", () => {
            e2.isValid && (e2.isValid = false, e2.isInvalid = true, e2.refreshState());
          }), e2.updateOriginalInput(), e2.refreshItems(), e2.close(false), e2.inputState(), e2.isSetup = true, a2.disabled ? e2.disable() : a2.readOnly ? e2.setReadOnly(true) : e2.enable(), e2.on("change", this.onChange), D(a2, "tomselected", "ts-hidden-accessible"), e2.trigger("initialize"), true === t2.preload && e2.preload();
        }
        setupOptions(e2 = [], t2 = []) {
          this.addOptions(e2), E(t2, (e3) => {
            this.registerOptionGroup(e3);
          });
        }
        setupTemplates() {
          var e2 = this, t2 = e2.settings.labelField, i2 = e2.settings.optgroupLabelField, s2 = { optgroup: (e3) => {
            let t3 = document.createElement("div");
            return t3.className = "optgroup", t3.appendChild(e3.options), t3;
          }, optgroup_header: (e3, t3) => '<div class="optgroup-header">' + t3(e3[i2]) + "</div>", option: (e3, i3) => "<div>" + i3(e3[t2]) + "</div>", item: (e3, i3) => "<div>" + i3(e3[t2]) + "</div>", option_create: (e3, t3) => '<div class="create">Add <strong>' + t3(e3.input) + "</strong>&hellip;</div>", no_results: () => '<div class="no-results">No results found</div>', loading: () => '<div class="spinner"></div>', not_loading: () => {
          }, dropdown: () => "<div></div>" };
          e2.settings.render = Object.assign({}, s2, e2.settings.render);
        }
        setupCallbacks() {
          var e2, t2, i2 = { initialize: "onInitialize", change: "onChange", item_add: "onItemAdd", item_remove: "onItemRemove", item_select: "onItemSelect", clear: "onClear", option_add: "onOptionAdd", option_remove: "onOptionRemove", option_clear: "onOptionClear", optgroup_add: "onOptionGroupAdd", optgroup_remove: "onOptionGroupRemove", optgroup_clear: "onOptionGroupClear", dropdown_open: "onDropdownOpen", dropdown_close: "onDropdownClose", type: "onType", load: "onLoad", focus: "onFocus", blur: "onBlur" };
          for (e2 in i2)
            (t2 = this.settings[i2[e2]]) && this.on(e2, t2);
        }
        sync(e2 = true) {
          const t2 = this, i2 = e2 ? ae(t2.input, { delimiter: t2.settings.delimiter }) : t2.settings;
          t2.setupOptions(i2.options, i2.optgroups), t2.setValue(i2.items || [], true), t2.lastQuery = null;
        }
        onClick() {
          var e2 = this;
          if (e2.activeItems.length > 0)
            return e2.clearActiveItems(), void e2.focus();
          e2.isFocused && e2.isOpen ? e2.blur() : e2.focus();
        }
        onMouseDown() {
        }
        onChange() {
          V(this.input, "input"), V(this.input, "change");
        }
        onPaste(e2) {
          var t2 = this;
          t2.isInputHidden || t2.isLocked ? ie(e2) : t2.settings.splitOn && setTimeout(() => {
            var e3 = t2.inputValue();
            if (e3.match(t2.settings.splitOn)) {
              var i2 = e3.trim().split(t2.settings.splitOn);
              E(i2, (e4) => {
                X(e4) && (this.options[e4] ? t2.addItem(e4) : t2.createItem(e4));
              });
            }
          }, 0);
        }
        onKeyPress(e2) {
          var t2 = this;
          if (!t2.isLocked) {
            var i2 = String.fromCharCode(e2.keyCode || e2.which);
            return t2.settings.create && "multi" === t2.settings.mode && i2 === t2.settings.delimiter ? (t2.createItem(), void ie(e2)) : void 0;
          }
          ie(e2);
        }
        onKeyDown(e2) {
          var t2 = this;
          if (t2.ignoreHover = true, t2.isLocked)
            9 !== e2.keyCode && ie(e2);
          else {
            switch (e2.keyCode) {
              case 65:
                if (ne(J, e2) && "" == t2.control_input.value)
                  return ie(e2), void t2.selectAll();
                break;
              case 27:
                return t2.isOpen && (ie(e2, true), t2.close()), void t2.clearActiveItems();
              case 40:
                if (!t2.isOpen && t2.hasOptions)
                  t2.open();
                else if (t2.activeOption) {
                  let e3 = t2.getAdjacent(t2.activeOption, 1);
                  e3 && t2.setActiveOption(e3);
                }
                return void ie(e2);
              case 38:
                if (t2.activeOption) {
                  let e3 = t2.getAdjacent(t2.activeOption, -1);
                  e3 && t2.setActiveOption(e3);
                }
                return void ie(e2);
              case 13:
                return void (t2.canSelect(t2.activeOption) ? (t2.onOptionSelect(e2, t2.activeOption), ie(e2)) : (t2.settings.create && t2.createItem() || document.activeElement == t2.control_input && t2.isOpen) && ie(e2));
              case 37:
                return void t2.advanceSelection(-1, e2);
              case 39:
                return void t2.advanceSelection(1, e2);
              case 9:
                return void (t2.settings.selectOnTab && (t2.canSelect(t2.activeOption) && (t2.onOptionSelect(e2, t2.activeOption), ie(e2)), t2.settings.create && t2.createItem() && ie(e2)));
              case 8:
              case 46:
                return void t2.deleteSelection(e2);
            }
            t2.isInputHidden && !ne(J, e2) && ie(e2);
          }
        }
        onInput(e2) {
          if (this.isLocked)
            return;
          const t2 = this.inputValue();
          this.lastValue !== t2 && (this.lastValue = t2, "" != t2 ? (this.refreshTimeout && clearTimeout(this.refreshTimeout), this.refreshTimeout = ((e3, t3) => t3 > 0 ? setTimeout(e3, t3) : (e3.call(null), null))(() => {
            this.refreshTimeout = null, this._onInput();
          }, this.settings.refreshThrottle)) : this._onInput());
        }
        _onInput() {
          const e2 = this.lastValue;
          this.settings.shouldLoad.call(this, e2) && this.load(e2), this.refreshOptions(), this.trigger("type", e2);
        }
        onOptionHover(e2, t2) {
          this.ignoreHover || this.setActiveOption(t2, false);
        }
        onFocus(e2) {
          var t2 = this, i2 = t2.isFocused;
          if (t2.isDisabled || t2.isReadOnly)
            return t2.blur(), void ie(e2);
          t2.ignoreFocus || (t2.isFocused = true, "focus" === t2.settings.preload && t2.preload(), i2 || t2.trigger("focus"), t2.activeItems.length || (t2.inputState(), t2.refreshOptions(!!t2.settings.openOnFocus)), t2.refreshState());
        }
        onBlur(e2) {
          if (false !== document.hasFocus()) {
            var t2 = this;
            if (t2.isFocused) {
              t2.isFocused = false, t2.ignoreFocus = false;
              var i2 = () => {
                t2.close(), t2.setActiveItem(), t2.setCaret(t2.items.length), t2.trigger("blur");
              };
              t2.settings.create && t2.settings.createOnBlur ? t2.createItem(null, i2) : i2();
            }
          }
        }
        onOptionSelect(e2, t2) {
          var i2, s2 = this;
          t2.parentElement && t2.parentElement.matches("[data-disabled]") || (t2.classList.contains("create") ? s2.createItem(null, () => {
            s2.settings.closeAfterSelect && s2.close();
          }) : void 0 !== (i2 = t2.dataset.value) && (s2.lastQuery = null, s2.addItem(i2), s2.settings.closeAfterSelect && s2.close(), !s2.settings.hideSelected && e2.type && /click/.test(e2.type) && s2.setActiveOption(t2)));
        }
        canSelect(e2) {
          return !!(this.isOpen && e2 && this.dropdown_content.contains(e2));
        }
        onItemSelect(e2, t2) {
          var i2 = this;
          return !i2.isLocked && "multi" === i2.settings.mode && (ie(e2), i2.setActiveItem(t2, e2), true);
        }
        canLoad(e2) {
          return !!this.settings.load && !this.loadedSearches.hasOwnProperty(e2);
        }
        load(e2) {
          const t2 = this;
          if (!t2.canLoad(e2))
            return;
          D(t2.wrapper, t2.settings.loadingClass), t2.loading++;
          const i2 = t2.loadCallback.bind(t2);
          t2.settings.load.call(t2, e2, i2);
        }
        loadCallback(e2, t2) {
          const i2 = this;
          i2.loading = Math.max(i2.loading - 1, 0), i2.lastQuery = null, i2.clearActiveOption(), i2.setupOptions(e2, t2), i2.refreshOptions(i2.isFocused && !i2.isInputHidden), i2.loading || R(i2.wrapper, i2.settings.loadingClass), i2.trigger("load", e2, t2);
        }
        preload() {
          var e2 = this.wrapper.classList;
          e2.contains("preloaded") || (e2.add("preloaded"), this.load(""));
        }
        setTextboxValue(e2 = "") {
          var t2 = this.control_input;
          t2.value !== e2 && (t2.value = e2, V(t2, "update"), this.lastValue = e2);
        }
        getValue() {
          return this.is_select_tag && this.input.hasAttribute("multiple") ? this.items : this.items.join(this.settings.delimiter);
        }
        setValue(e2, t2) {
          te(this, t2 ? [] : ["change"], () => {
            this.clear(t2), this.addItems(e2, t2);
          });
        }
        setMaxItems(e2) {
          0 === e2 && (e2 = null), this.settings.maxItems = e2, this.refreshState();
        }
        setActiveItem(e2, t2) {
          var i2, s2, n2, o2, r2, l2, a2 = this;
          if ("single" !== a2.settings.mode) {
            if (!e2)
              return a2.clearActiveItems(), void (a2.isFocused && a2.inputState());
            if ("click" === (i2 = t2 && t2.type.toLowerCase()) && ne("shiftKey", t2) && a2.activeItems.length) {
              for (l2 = a2.getLastActive(), (n2 = Array.prototype.indexOf.call(a2.control.children, l2)) > (o2 = Array.prototype.indexOf.call(a2.control.children, e2)) && (r2 = n2, n2 = o2, o2 = r2), s2 = n2; s2 <= o2; s2++)
                e2 = a2.control.children[s2], -1 === a2.activeItems.indexOf(e2) && a2.setActiveItemClass(e2);
              ie(t2);
            } else
              "click" === i2 && ne(J, t2) || "keydown" === i2 && ne("shiftKey", t2) ? e2.classList.contains("active") ? a2.removeActiveItem(e2) : a2.setActiveItemClass(e2) : (a2.clearActiveItems(), a2.setActiveItemClass(e2));
            a2.inputState(), a2.isFocused || a2.focus();
          }
        }
        setActiveItemClass(e2) {
          const t2 = this, i2 = t2.control.querySelector(".last-active");
          i2 && R(i2, "last-active"), D(e2, "active last-active"), t2.trigger("item_select", e2), -1 == t2.activeItems.indexOf(e2) && t2.activeItems.push(e2);
        }
        removeActiveItem(e2) {
          var t2 = this.activeItems.indexOf(e2);
          this.activeItems.splice(t2, 1), R(e2, "active");
        }
        clearActiveItems() {
          R(this.activeItems, "active"), this.activeItems = [];
        }
        setActiveOption(e2, t2 = true) {
          e2 !== this.activeOption && (this.clearActiveOption(), e2 && (this.activeOption = e2, Q(this.focus_node, { "aria-activedescendant": e2.getAttribute("id") }), Q(e2, { "aria-selected": "true" }), D(e2, "active"), t2 && this.scrollToOption(e2)));
        }
        scrollToOption(e2, t2) {
          if (!e2)
            return;
          const i2 = this.dropdown_content, s2 = i2.clientHeight, n2 = i2.scrollTop || 0, o2 = e2.offsetHeight, r2 = e2.getBoundingClientRect().top - i2.getBoundingClientRect().top + n2;
          r2 + o2 > s2 + n2 ? this.scroll(r2 - s2 + o2, t2) : r2 < n2 && this.scroll(r2, t2);
        }
        scroll(e2, t2) {
          const i2 = this.dropdown_content;
          t2 && (i2.style.scrollBehavior = t2), i2.scrollTop = e2, i2.style.scrollBehavior = "";
        }
        clearActiveOption() {
          this.activeOption && (R(this.activeOption, "active"), Q(this.activeOption, { "aria-selected": null })), this.activeOption = null, Q(this.focus_node, { "aria-activedescendant": null });
        }
        selectAll() {
          const e2 = this;
          if ("single" === e2.settings.mode)
            return;
          const t2 = e2.controlChildren();
          t2.length && (e2.inputState(), e2.close(), e2.activeItems = t2, E(t2, (t3) => {
            e2.setActiveItemClass(t3);
          }));
        }
        inputState() {
          var e2 = this;
          e2.control.contains(e2.control_input) && (Q(e2.control_input, { placeholder: e2.settings.placeholder }), e2.activeItems.length > 0 || !e2.isFocused && e2.settings.hidePlaceholder && e2.items.length > 0 ? (e2.setTextboxValue(), e2.isInputHidden = true) : (e2.settings.hidePlaceholder && e2.items.length > 0 && Q(e2.control_input, { placeholder: "" }), e2.isInputHidden = false), e2.wrapper.classList.toggle("input-hidden", e2.isInputHidden));
        }
        inputValue() {
          return this.control_input.value.trim();
        }
        focus() {
          var e2 = this;
          e2.isDisabled || e2.isReadOnly || (e2.ignoreFocus = true, e2.control_input.offsetWidth ? e2.control_input.focus() : e2.focus_node.focus(), setTimeout(() => {
            e2.ignoreFocus = false, e2.onFocus();
          }, 0));
        }
        blur() {
          this.focus_node.blur(), this.onBlur();
        }
        getScoreFunction(e2) {
          return this.sifter.getScoreFunction(e2, this.getSearchOptions());
        }
        getSearchOptions() {
          var e2 = this.settings, t2 = e2.sortField;
          return "string" == typeof e2.sortField && (t2 = [{ field: e2.sortField }]), { fields: e2.searchField, conjunction: e2.searchConjunction, sort: t2, nesting: e2.nesting };
        }
        search(e2) {
          var t2, i2, s2 = this, n2 = this.getSearchOptions();
          if (s2.settings.score && "function" != typeof (i2 = s2.settings.score.call(s2, e2)))
            throw new Error('Tom Select "score" setting must be a function that returns a function');
          return e2 !== s2.lastQuery ? (s2.lastQuery = e2, t2 = s2.sifter.search(e2, Object.assign(n2, { score: i2 })), s2.currentResults = t2) : t2 = Object.assign({}, s2.currentResults), s2.settings.hideSelected && (t2.items = t2.items.filter((e3) => {
            let t3 = X(e3.id);
            return !(t3 && -1 !== s2.items.indexOf(t3));
          })), t2;
        }
        refreshOptions(e2 = true) {
          var t2, i2, s2, n2, o2, r2, l2, a2, c2, d2;
          const u2 = {}, p2 = [];
          var h2 = this, g2 = h2.inputValue();
          const f2 = g2 === h2.lastQuery || "" == g2 && null == h2.lastQuery;
          var v2 = h2.search(g2), m2 = null, y2 = h2.settings.shouldOpen || false, O2 = h2.dropdown_content;
          f2 && (m2 = h2.activeOption) && (c2 = m2.closest("[data-group]")), n2 = v2.items.length, "number" == typeof h2.settings.maxOptions && (n2 = Math.min(n2, h2.settings.maxOptions)), n2 > 0 && (y2 = true);
          const b2 = (e3, t3) => {
            let i3 = u2[e3];
            if (void 0 !== i3) {
              let e4 = p2[i3];
              if (void 0 !== e4)
                return [i3, e4.fragment];
            }
            let s3 = document.createDocumentFragment();
            return i3 = p2.length, p2.push({ fragment: s3, order: t3, optgroup: e3 }), [i3, s3];
          };
          for (t2 = 0; t2 < n2; t2++) {
            let e3 = v2.items[t2];
            if (!e3)
              continue;
            let n3 = e3.id, l3 = h2.options[n3];
            if (void 0 === l3)
              continue;
            let a3 = Y(n3), d3 = h2.getOption(a3, true);
            for (h2.settings.hideSelected || d3.classList.toggle("selected", h2.items.includes(a3)), o2 = l3[h2.settings.optgroupField] || "", i2 = 0, s2 = (r2 = Array.isArray(o2) ? o2 : [o2]) && r2.length; i2 < s2; i2++) {
              o2 = r2[i2];
              let e4 = l3.$order, t3 = h2.optgroups[o2];
              void 0 === t3 ? o2 = "" : e4 = t3.$order;
              const [s3, a4] = b2(o2, e4);
              i2 > 0 && (d3 = d3.cloneNode(true), Q(d3, { id: l3.$id + "-clone-" + i2, "aria-selected": null }), d3.classList.add("ts-cloned"), R(d3, "active"), h2.activeOption && h2.activeOption.dataset.value == n3 && c2 && c2.dataset.group === o2.toString() && (m2 = d3)), a4.appendChild(d3), "" != o2 && (u2[o2] = s3);
            }
          }
          var w2;
          h2.settings.lockOptgroupOrder && p2.sort((e3, t3) => e3.order - t3.order), l2 = document.createDocumentFragment(), E(p2, (e3) => {
            let t3 = e3.fragment, i3 = e3.optgroup;
            if (!t3 || !t3.children.length)
              return;
            let s3 = h2.optgroups[i3];
            if (void 0 !== s3) {
              let e4 = document.createDocumentFragment(), i4 = h2.render("optgroup_header", s3);
              le(e4, i4), le(e4, t3);
              let n3 = h2.render("optgroup", { group: s3, options: e4 });
              le(l2, n3);
            } else
              le(l2, t3);
          }), O2.innerHTML = "", le(O2, l2), h2.settings.highlight && (w2 = O2.querySelectorAll("span.highlight"), Array.prototype.forEach.call(w2, function(e3) {
            var t3 = e3.parentNode;
            t3.replaceChild(e3.firstChild, e3), t3.normalize();
          }), v2.query.length && v2.tokens.length && E(v2.tokens, (e3) => {
            U(O2, e3.regex);
          }));
          var _2 = (e3) => {
            let t3 = h2.render(e3, { input: g2 });
            return t3 && (y2 = true, O2.insertBefore(t3, O2.firstChild)), t3;
          };
          if (h2.loading ? _2("loading") : h2.settings.shouldLoad.call(h2, g2) ? 0 === v2.items.length && _2("no_results") : _2("not_loading"), (a2 = h2.canCreate(g2)) && (d2 = _2("option_create")), h2.hasOptions = v2.items.length > 0 || a2, y2) {
            if (v2.items.length > 0) {
              if (m2 || "single" !== h2.settings.mode || null == h2.items[0] || (m2 = h2.getOption(h2.items[0])), !O2.contains(m2)) {
                let e3 = 0;
                d2 && !h2.settings.addPrecedence && (e3 = 1), m2 = h2.selectable()[e3];
              }
            } else
              d2 && (m2 = d2);
            e2 && !h2.isOpen && (h2.open(), h2.scrollToOption(m2, "auto")), h2.setActiveOption(m2);
          } else
            h2.clearActiveOption(), e2 && h2.isOpen && h2.close(false);
        }
        selectable() {
          return this.dropdown_content.querySelectorAll("[data-selectable]");
        }
        addOption(e2, t2 = false) {
          const i2 = this;
          if (Array.isArray(e2))
            return i2.addOptions(e2, t2), false;
          const s2 = X(e2[i2.settings.valueField]);
          return null !== s2 && !i2.options.hasOwnProperty(s2) && (e2.$order = e2.$order || ++i2.order, e2.$id = i2.inputId + "-opt-" + e2.$order, i2.options[s2] = e2, i2.lastQuery = null, t2 && (i2.userOptions[s2] = t2, i2.trigger("option_add", s2, e2)), s2);
        }
        addOptions(e2, t2 = false) {
          E(e2, (e3) => {
            this.addOption(e3, t2);
          });
        }
        registerOption(e2) {
          return this.addOption(e2);
        }
        registerOptionGroup(e2) {
          var t2 = X(e2[this.settings.optgroupValueField]);
          return null !== t2 && (e2.$order = e2.$order || ++this.order, this.optgroups[t2] = e2, t2);
        }
        addOptionGroup(e2, t2) {
          var i2;
          t2[this.settings.optgroupValueField] = e2, (i2 = this.registerOptionGroup(t2)) && this.trigger("optgroup_add", i2, t2);
        }
        removeOptionGroup(e2) {
          this.optgroups.hasOwnProperty(e2) && (delete this.optgroups[e2], this.clearCache(), this.trigger("optgroup_remove", e2));
        }
        clearOptionGroups() {
          this.optgroups = {}, this.clearCache(), this.trigger("optgroup_clear");
        }
        updateOption(e2, t2) {
          const i2 = this;
          var s2, n2;
          const o2 = X(e2), r2 = X(t2[i2.settings.valueField]);
          if (null === o2)
            return;
          const l2 = i2.options[o2];
          if (null == l2)
            return;
          if ("string" != typeof r2)
            throw new Error("Value must be set in option data");
          const a2 = i2.getOption(o2), c2 = i2.getItem(o2);
          if (t2.$order = t2.$order || l2.$order, delete i2.options[o2], i2.uncacheValue(r2), i2.options[r2] = t2, a2) {
            if (i2.dropdown_content.contains(a2)) {
              const e3 = i2._render("option", t2);
              G(a2, e3), i2.activeOption === a2 && i2.setActiveOption(e3);
            }
            a2.remove();
          }
          c2 && (-1 !== (n2 = i2.items.indexOf(o2)) && i2.items.splice(n2, 1, r2), s2 = i2._render("item", t2), c2.classList.contains("active") && D(s2, "active"), G(c2, s2)), i2.lastQuery = null;
        }
        removeOption(e2, t2) {
          const i2 = this;
          e2 = Y(e2), i2.uncacheValue(e2), delete i2.userOptions[e2], delete i2.options[e2], i2.lastQuery = null, i2.trigger("option_remove", e2), i2.removeItem(e2, t2);
        }
        clearOptions(e2) {
          const t2 = (e2 || this.clearFilter).bind(this);
          this.loadedSearches = {}, this.userOptions = {}, this.clearCache();
          const i2 = {};
          E(this.options, (e3, s2) => {
            t2(e3, s2) && (i2[s2] = e3);
          }), this.options = this.sifter.items = i2, this.lastQuery = null, this.trigger("option_clear");
        }
        clearFilter(e2, t2) {
          return this.items.indexOf(t2) >= 0;
        }
        getOption(e2, t2 = false) {
          const i2 = X(e2);
          if (null === i2)
            return null;
          const s2 = this.options[i2];
          if (null != s2) {
            if (s2.$div)
              return s2.$div;
            if (t2)
              return this._render("option", s2);
          }
          return null;
        }
        getAdjacent(e2, t2, i2 = "option") {
          var s2;
          if (!e2)
            return null;
          s2 = "item" == i2 ? this.controlChildren() : this.dropdown_content.querySelectorAll("[data-selectable]");
          for (let i3 = 0; i3 < s2.length; i3++)
            if (s2[i3] == e2)
              return t2 > 0 ? s2[i3 + 1] : s2[i3 - 1];
          return null;
        }
        getItem(e2) {
          if ("object" == typeof e2)
            return e2;
          var t2 = X(e2);
          return null !== t2 ? this.control.querySelector(`[data-value="${re(t2)}"]`) : null;
        }
        addItems(e2, t2) {
          var i2 = this, s2 = Array.isArray(e2) ? e2 : [e2];
          const n2 = (s2 = s2.filter((e3) => -1 === i2.items.indexOf(e3)))[s2.length - 1];
          s2.forEach((e3) => {
            i2.isPending = e3 !== n2, i2.addItem(e3, t2);
          });
        }
        addItem(e2, t2) {
          te(this, t2 ? [] : ["change", "dropdown_close"], () => {
            var i2, s2;
            const n2 = this, o2 = n2.settings.mode, r2 = X(e2);
            if ((!r2 || -1 === n2.items.indexOf(r2) || ("single" === o2 && n2.close(), "single" !== o2 && n2.settings.duplicates)) && null !== r2 && n2.options.hasOwnProperty(r2) && ("single" === o2 && n2.clear(t2), "multi" !== o2 || !n2.isFull())) {
              if (i2 = n2._render("item", n2.options[r2]), n2.control.contains(i2) && (i2 = i2.cloneNode(true)), s2 = n2.isFull(), n2.items.splice(n2.caretPos, 0, r2), n2.insertAtCaret(i2), n2.isSetup) {
                if (!n2.isPending && n2.settings.hideSelected) {
                  let e3 = n2.getOption(r2), t3 = n2.getAdjacent(e3, 1);
                  t3 && n2.setActiveOption(t3);
                }
                n2.isPending || n2.settings.closeAfterSelect || n2.refreshOptions(n2.isFocused && "single" !== o2), 0 != n2.settings.closeAfterSelect && n2.isFull() ? n2.close() : n2.isPending || n2.positionDropdown(), n2.trigger("item_add", r2, i2), n2.isPending || n2.updateOriginalInput({ silent: t2 });
              }
              (!n2.isPending || !s2 && n2.isFull()) && (n2.inputState(), n2.refreshState());
            }
          });
        }
        removeItem(e2 = null, t2) {
          const i2 = this;
          if (!(e2 = i2.getItem(e2)))
            return;
          var s2, n2;
          const o2 = e2.dataset.value;
          s2 = K(e2), e2.remove(), e2.classList.contains("active") && (n2 = i2.activeItems.indexOf(e2), i2.activeItems.splice(n2, 1), R(e2, "active")), i2.items.splice(s2, 1), i2.lastQuery = null, !i2.settings.persist && i2.userOptions.hasOwnProperty(o2) && i2.removeOption(o2, t2), s2 < i2.caretPos && i2.setCaret(i2.caretPos - 1), i2.updateOriginalInput({ silent: t2 }), i2.refreshState(), i2.positionDropdown(), i2.trigger("item_remove", o2, e2);
        }
        createItem(e2 = null, t2 = () => {
        }) {
          3 === arguments.length && (t2 = arguments[2]), "function" != typeof t2 && (t2 = () => {
          });
          var i2, s2 = this, n2 = s2.caretPos;
          if (e2 = e2 || s2.inputValue(), !s2.canCreate(e2))
            return t2(), false;
          s2.lock();
          var o2 = false, r2 = (e3) => {
            if (s2.unlock(), !e3 || "object" != typeof e3)
              return t2();
            var i3 = X(e3[s2.settings.valueField]);
            if ("string" != typeof i3)
              return t2();
            s2.setTextboxValue(), s2.addOption(e3, true), s2.setCaret(n2), s2.addItem(i3), t2(e3), o2 = true;
          };
          return i2 = "function" == typeof s2.settings.create ? s2.settings.create.call(this, e2, r2) : { [s2.settings.labelField]: e2, [s2.settings.valueField]: e2 }, o2 || r2(i2), true;
        }
        refreshItems() {
          var e2 = this;
          e2.lastQuery = null, e2.isSetup && e2.addItems(e2.items), e2.updateOriginalInput(), e2.refreshState();
        }
        refreshState() {
          const e2 = this;
          e2.refreshValidityState();
          const t2 = e2.isFull(), i2 = e2.isLocked;
          e2.wrapper.classList.toggle("rtl", e2.rtl);
          const s2 = e2.wrapper.classList;
          var n2;
          s2.toggle("focus", e2.isFocused), s2.toggle("disabled", e2.isDisabled), s2.toggle("readonly", e2.isReadOnly), s2.toggle("required", e2.isRequired), s2.toggle("invalid", !e2.isValid), s2.toggle("locked", i2), s2.toggle("full", t2), s2.toggle("input-active", e2.isFocused && !e2.isInputHidden), s2.toggle("dropdown-active", e2.isOpen), s2.toggle("has-options", (n2 = e2.options, 0 === Object.keys(n2).length)), s2.toggle("has-items", e2.items.length > 0);
        }
        refreshValidityState() {
          var e2 = this;
          e2.input.validity && (e2.isValid = e2.input.validity.valid, e2.isInvalid = !e2.isValid);
        }
        isFull() {
          return null !== this.settings.maxItems && this.items.length >= this.settings.maxItems;
        }
        updateOriginalInput(e2 = {}) {
          const t2 = this;
          var i2, s2;
          const n2 = t2.input.querySelector('option[value=""]');
          if (t2.is_select_tag) {
            let l2 = function(e3, i3, s3) {
              return e3 || (e3 = j('<option value="' + Z(i3) + '">' + Z(s3) + "</option>")), e3 != n2 && t2.input.append(e3), o2.push(e3), (e3 != n2 || r2 > 0) && (e3.selected = true), e3;
            };
            const o2 = [], r2 = t2.input.querySelectorAll("option:checked").length;
            t2.input.querySelectorAll("option:checked").forEach((e3) => {
              e3.selected = false;
            }), 0 == t2.items.length && "single" == t2.settings.mode ? l2(n2, "", "") : t2.items.forEach((e3) => {
              if (i2 = t2.options[e3], s2 = i2[t2.settings.labelField] || "", o2.includes(i2.$option)) {
                l2(t2.input.querySelector(`option[value="${re(e3)}"]:not(:checked)`), e3, s2);
              } else
                i2.$option = l2(i2.$option, e3, s2);
            });
          } else
            t2.input.value = t2.getValue();
          t2.isSetup && (e2.silent || t2.trigger("change", t2.getValue()));
        }
        open() {
          var e2 = this;
          e2.isLocked || e2.isOpen || "multi" === e2.settings.mode && e2.isFull() || (e2.isOpen = true, Q(e2.focus_node, { "aria-expanded": "true" }), e2.refreshState(), q(e2.dropdown, { visibility: "hidden", display: "block" }), e2.positionDropdown(), q(e2.dropdown, { visibility: "visible", display: "block" }), e2.focus(), e2.trigger("dropdown_open", e2.dropdown));
        }
        close(e2 = true) {
          var t2 = this, i2 = t2.isOpen;
          e2 && (t2.setTextboxValue(), "single" === t2.settings.mode && t2.items.length && t2.inputState()), t2.isOpen = false, Q(t2.focus_node, { "aria-expanded": "false" }), q(t2.dropdown, { display: "none" }), t2.settings.hideSelected && t2.clearActiveOption(), t2.refreshState(), i2 && t2.trigger("dropdown_close", t2.dropdown);
        }
        positionDropdown() {
          if ("body" === this.settings.dropdownParent) {
            var e2 = this.control, t2 = e2.getBoundingClientRect(), i2 = e2.offsetHeight + t2.top + window.scrollY, s2 = t2.left + window.scrollX;
            q(this.dropdown, { width: t2.width + "px", top: i2 + "px", left: s2 + "px" });
          }
        }
        clear(e2) {
          var t2 = this;
          if (t2.items.length) {
            var i2 = t2.controlChildren();
            E(i2, (e3) => {
              t2.removeItem(e3, true);
            }), t2.inputState(), e2 || t2.updateOriginalInput(), t2.trigger("clear");
          }
        }
        insertAtCaret(e2) {
          const t2 = this, i2 = t2.caretPos, s2 = t2.control;
          s2.insertBefore(e2, s2.children[i2] || null), t2.setCaret(i2 + 1);
        }
        deleteSelection(e2) {
          var t2, i2, s2, n2, o2, r2 = this;
          t2 = e2 && 8 === e2.keyCode ? -1 : 1, i2 = { start: (o2 = r2.control_input).selectionStart || 0, length: (o2.selectionEnd || 0) - (o2.selectionStart || 0) };
          const l2 = [];
          if (r2.activeItems.length)
            n2 = B(r2.activeItems, t2), s2 = K(n2), t2 > 0 && s2++, E(r2.activeItems, (e3) => l2.push(e3));
          else if ((r2.isFocused || "single" === r2.settings.mode) && r2.items.length) {
            const e3 = r2.controlChildren();
            let s3;
            t2 < 0 && 0 === i2.start && 0 === i2.length ? s3 = e3[r2.caretPos - 1] : t2 > 0 && i2.start === r2.inputValue().length && (s3 = e3[r2.caretPos]), void 0 !== s3 && l2.push(s3);
          }
          if (!r2.shouldDelete(l2, e2))
            return false;
          for (ie(e2, true), void 0 !== s2 && r2.setCaret(s2); l2.length; )
            r2.removeItem(l2.pop());
          return r2.inputState(), r2.positionDropdown(), r2.refreshOptions(false), true;
        }
        shouldDelete(e2, t2) {
          const i2 = e2.map((e3) => e3.dataset.value);
          return !(!i2.length || "function" == typeof this.settings.onDelete && false === this.settings.onDelete(i2, t2));
        }
        advanceSelection(e2, t2) {
          var i2, s2, n2 = this;
          n2.rtl && (e2 *= -1), n2.inputValue().length || (ne(J, t2) || ne("shiftKey", t2) ? (s2 = (i2 = n2.getLastActive(e2)) ? i2.classList.contains("active") ? n2.getAdjacent(i2, e2, "item") : i2 : e2 > 0 ? n2.control_input.nextElementSibling : n2.control_input.previousElementSibling) && (s2.classList.contains("active") && n2.removeActiveItem(i2), n2.setActiveItemClass(s2)) : n2.moveCaret(e2));
        }
        moveCaret(e2) {
        }
        getLastActive(e2) {
          let t2 = this.control.querySelector(".last-active");
          if (t2)
            return t2;
          var i2 = this.control.querySelectorAll(".active");
          return i2 ? B(i2, e2) : void 0;
        }
        setCaret(e2) {
          this.caretPos = this.items.length;
        }
        controlChildren() {
          return Array.from(this.control.querySelectorAll("[data-ts-item]"));
        }
        lock() {
          this.setLocked(true);
        }
        unlock() {
          this.setLocked(false);
        }
        setLocked(e2 = this.isReadOnly || this.isDisabled) {
          this.isLocked = e2, this.refreshState();
        }
        disable() {
          this.setDisabled(true), this.close();
        }
        enable() {
          this.setDisabled(false);
        }
        setDisabled(e2) {
          this.focus_node.tabIndex = e2 ? -1 : this.tabIndex, this.isDisabled = e2, this.input.disabled = e2, this.control_input.disabled = e2, this.setLocked();
        }
        setReadOnly(e2) {
          this.isReadOnly = e2, this.input.readOnly = e2, this.control_input.readOnly = e2, this.setLocked();
        }
        destroy() {
          var e2 = this, t2 = e2.revertSettings;
          e2.trigger("destroy"), e2.off(), e2.wrapper.remove(), e2.dropdown.remove(), e2.input.innerHTML = t2.innerHTML, e2.input.tabIndex = t2.tabIndex, R(e2.input, "tomselected", "ts-hidden-accessible"), e2._destroy(), delete e2.input.tomselect;
        }
        render(e2, t2) {
          var i2, s2;
          const n2 = this;
          if ("function" != typeof this.settings.render[e2])
            return null;
          if (!(s2 = n2.settings.render[e2].call(this, t2, Z)))
            return null;
          if (s2 = j(s2), "option" === e2 || "option_create" === e2 ? t2[n2.settings.disabledField] ? Q(s2, { "aria-disabled": "true" }) : Q(s2, { "data-selectable": "" }) : "optgroup" === e2 && (i2 = t2.group[n2.settings.optgroupValueField], Q(s2, { "data-group": i2 }), t2.group[n2.settings.disabledField] && Q(s2, { "data-disabled": "" })), "option" === e2 || "item" === e2) {
            const i3 = Y(t2[n2.settings.valueField]);
            Q(s2, { "data-value": i3 }), "item" === e2 ? (D(s2, n2.settings.itemClass), Q(s2, { "data-ts-item": "" })) : (D(s2, n2.settings.optionClass), Q(s2, { role: "option", id: t2.$id }), t2.$div = s2, n2.options[i3] = t2);
          }
          return s2;
        }
        _render(e2, t2) {
          const i2 = this.render(e2, t2);
          if (null == i2)
            throw "HTMLElement expected";
          return i2;
        }
        clearCache() {
          E(this.options, (e2) => {
            e2.$div && (e2.$div.remove(), delete e2.$div);
          });
        }
        uncacheValue(e2) {
          const t2 = this.getOption(e2);
          t2 && t2.remove();
        }
        canCreate(e2) {
          return this.settings.create && e2.length > 0 && this.settings.createFilter.call(this, e2);
        }
        hook(e2, t2, i2) {
          var s2 = this, n2 = s2[t2];
          s2[t2] = function() {
            var t3, o2;
            return "after" === e2 && (t3 = n2.apply(s2, arguments)), o2 = i2.apply(s2, arguments), "instead" === e2 ? o2 : ("before" === e2 && (t3 = n2.apply(s2, arguments)), t3);
          };
        }
      }
      return de.define("change_listener", function() {
        se(this.input, "change", () => {
          this.sync();
        });
      }), de.define("checkbox_options", function(e2) {
        var t2 = this, i2 = t2.onOptionSelect;
        t2.settings.hideSelected = false;
        const s2 = Object.assign({ className: "tomselect-checkbox", checkedClassNames: void 0, uncheckedClassNames: void 0 }, e2);
        var n2 = function(e3, t3) {
          t3 ? (e3.checked = true, s2.uncheckedClassNames && e3.classList.remove(...s2.uncheckedClassNames), s2.checkedClassNames && e3.classList.add(...s2.checkedClassNames)) : (e3.checked = false, s2.checkedClassNames && e3.classList.remove(...s2.checkedClassNames), s2.uncheckedClassNames && e3.classList.add(...s2.uncheckedClassNames));
        }, o2 = function(e3) {
          setTimeout(() => {
            var t3 = e3.querySelector("input." + s2.className);
            t3 instanceof HTMLInputElement && n2(t3, e3.classList.contains("selected"));
          }, 1);
        };
        t2.hook("after", "setupTemplates", () => {
          var e3 = t2.settings.render.option;
          t2.settings.render.option = (i3, o3) => {
            var r2 = j(e3.call(t2, i3, o3)), l2 = document.createElement("input");
            s2.className && l2.classList.add(s2.className), l2.addEventListener("click", function(e4) {
              ie(e4);
            }), l2.type = "checkbox";
            const a2 = X(i3[t2.settings.valueField]);
            return n2(l2, !!(a2 && t2.items.indexOf(a2) > -1)), r2.prepend(l2), r2;
          };
        }), t2.on("item_remove", (e3) => {
          var i3 = t2.getOption(e3);
          i3 && (i3.classList.remove("selected"), o2(i3));
        }), t2.on("item_add", (e3) => {
          var i3 = t2.getOption(e3);
          i3 && o2(i3);
        }), t2.hook("instead", "onOptionSelect", (e3, s3) => {
          if (s3.classList.contains("selected"))
            return s3.classList.remove("selected"), t2.removeItem(s3.dataset.value), t2.refreshOptions(), void ie(e3, true);
          i2.call(t2, e3, s3), o2(s3);
        });
      }), de.define("clear_button", function(e2) {
        const t2 = this, i2 = Object.assign({ className: "clear-button", title: "Clear All", html: (e3) => `<div class="${e3.className}" title="${e3.title}">&#10799;</div>` }, e2);
        t2.on("initialize", () => {
          var e3 = j(i2.html(i2));
          e3.addEventListener("click", (e4) => {
            t2.isLocked || (t2.clear(), "single" === t2.settings.mode && t2.settings.allowEmptyOption && t2.addItem(""), e4.preventDefault(), e4.stopPropagation());
          }), t2.control.appendChild(e3);
        });
      }), de.define("drag_drop", function() {
        var e2 = this;
        if ("multi" !== e2.settings.mode)
          return;
        var t2 = e2.lock, i2 = e2.unlock;
        let s2, n2 = true;
        e2.hook("after", "setupTemplates", () => {
          var t3 = e2.settings.render.item;
          e2.settings.render.item = (i3, o2) => {
            const r2 = j(t3.call(e2, i3, o2));
            Q(r2, { draggable: "true" });
            const l2 = (e3) => {
              e3.preventDefault(), r2.classList.add("ts-drag-over"), a2(r2, s2);
            }, a2 = (e3, t4) => {
              var i4, s3, n3;
              void 0 !== t4 && (((e4, t5) => {
                do {
                  var i5;
                  if (e4 == (t5 = null == (i5 = t5) ? void 0 : i5.previousElementSibling))
                    return true;
                } while (t5 && t5.previousElementSibling);
                return false;
              })(t4, r2) ? (s3 = t4, null == (n3 = (i4 = e3).parentNode) || n3.insertBefore(s3, i4.nextSibling)) : ((e4, t5) => {
                var i5;
                null == (i5 = e4.parentNode) || i5.insertBefore(t5, e4);
              })(e3, t4));
            };
            return se(r2, "mousedown", (e3) => {
              n2 || ie(e3), e3.stopPropagation();
            }), se(r2, "dragstart", (e3) => {
              s2 = r2, setTimeout(() => {
                r2.classList.add("ts-dragging");
              }, 0);
            }), se(r2, "dragenter", l2), se(r2, "dragover", l2), se(r2, "dragleave", () => {
              r2.classList.remove("ts-drag-over");
            }), se(r2, "dragend", () => {
              var t4;
              document.querySelectorAll(".ts-drag-over").forEach((e3) => e3.classList.remove("ts-drag-over")), null == (t4 = s2) || t4.classList.remove("ts-dragging"), s2 = void 0;
              var i4 = [];
              e2.control.querySelectorAll("[data-value]").forEach((e3) => {
                if (e3.dataset.value) {
                  let t5 = e3.dataset.value;
                  t5 && i4.push(t5);
                }
              }), e2.setValue(i4);
            }), r2;
          };
        }), e2.hook("instead", "lock", () => (n2 = false, t2.call(e2))), e2.hook("instead", "unlock", () => (n2 = true, i2.call(e2)));
      }), de.define("dropdown_header", function(e2) {
        const t2 = this, i2 = Object.assign({ title: "Untitled", headerClass: "dropdown-header", titleRowClass: "dropdown-header-title", labelClass: "dropdown-header-label", closeClass: "dropdown-header-close", html: (e3) => '<div class="' + e3.headerClass + '"><div class="' + e3.titleRowClass + '"><span class="' + e3.labelClass + '">' + e3.title + '</span><a class="' + e3.closeClass + '">&times;</a></div></div>' }, e2);
        t2.on("initialize", () => {
          var e3 = j(i2.html(i2)), s2 = e3.querySelector("." + i2.closeClass);
          s2 && s2.addEventListener("click", (e4) => {
            ie(e4, true), t2.close();
          }), t2.dropdown.insertBefore(e3, t2.dropdown.firstChild);
        });
      }), de.define("caret_position", function() {
        var e2 = this;
        e2.hook("instead", "setCaret", (t2) => {
          "single" !== e2.settings.mode && e2.control.contains(e2.control_input) ? (t2 = Math.max(0, Math.min(e2.items.length, t2))) == e2.caretPos || e2.isPending || e2.controlChildren().forEach((i2, s2) => {
            s2 < t2 ? e2.control_input.insertAdjacentElement("beforebegin", i2) : e2.control.appendChild(i2);
          }) : t2 = e2.items.length, e2.caretPos = t2;
        }), e2.hook("instead", "moveCaret", (t2) => {
          if (!e2.isFocused)
            return;
          const i2 = e2.getLastActive(t2);
          if (i2) {
            const s2 = K(i2);
            e2.setCaret(t2 > 0 ? s2 + 1 : s2), e2.setActiveItem(), R(i2, "last-active");
          } else
            e2.setCaret(e2.caretPos + t2);
        });
      }), de.define("dropdown_input", function() {
        const e2 = this;
        e2.settings.shouldOpen = true, e2.hook("before", "setup", () => {
          e2.focus_node = e2.control, D(e2.control_input, "dropdown-input");
          const t2 = j('<div class="dropdown-input-wrap">');
          t2.append(e2.control_input), e2.dropdown.insertBefore(t2, e2.dropdown.firstChild);
          const i2 = j('<input class="items-placeholder" tabindex="-1" />');
          i2.placeholder = e2.settings.placeholder || "", e2.control.append(i2);
        }), e2.on("initialize", () => {
          e2.control_input.addEventListener("keydown", (t3) => {
            switch (t3.keyCode) {
              case 27:
                return e2.isOpen && (ie(t3, true), e2.close()), void e2.clearActiveItems();
              case 9:
                e2.focus_node.tabIndex = -1;
            }
            return e2.onKeyDown.call(e2, t3);
          }), e2.on("blur", () => {
            e2.focus_node.tabIndex = e2.isDisabled ? -1 : e2.tabIndex;
          }), e2.on("dropdown_open", () => {
            e2.control_input.focus();
          });
          const t2 = e2.onBlur;
          e2.hook("instead", "onBlur", (i2) => {
            if (!i2 || i2.relatedTarget != e2.control_input)
              return t2.call(e2);
          }), se(e2.control_input, "blur", () => e2.onBlur()), e2.hook("before", "close", () => {
            e2.isOpen && e2.focus_node.focus({ preventScroll: true });
          });
        });
      }), de.define("input_autogrow", function() {
        var e2 = this;
        e2.on("initialize", () => {
          var t2 = document.createElement("span"), i2 = e2.control_input;
          t2.style.cssText = "position:absolute; top:-99999px; left:-99999px; width:auto; padding:0; white-space:pre; ", e2.wrapper.appendChild(t2);
          for (const e3 of ["letterSpacing", "fontSize", "fontFamily", "fontWeight", "textTransform"])
            t2.style[e3] = i2.style[e3];
          var s2 = () => {
            t2.textContent = i2.value, i2.style.width = t2.clientWidth + "px";
          };
          s2(), e2.on("update item_add item_remove", s2), se(i2, "input", s2), se(i2, "keyup", s2), se(i2, "blur", s2), se(i2, "update", s2);
        });
      }), de.define("no_backspace_delete", function() {
        var e2 = this, t2 = e2.deleteSelection;
        this.hook("instead", "deleteSelection", (i2) => !!e2.activeItems.length && t2.call(e2, i2));
      }), de.define("no_active_items", function() {
        this.hook("instead", "setActiveItem", () => {
        }), this.hook("instead", "selectAll", () => {
        });
      }), de.define("optgroup_columns", function() {
        var e2 = this, t2 = e2.onKeyDown;
        e2.hook("instead", "onKeyDown", (i2) => {
          var s2, n2, o2, r2;
          if (!e2.isOpen || 37 !== i2.keyCode && 39 !== i2.keyCode)
            return t2.call(e2, i2);
          e2.ignoreHover = true, r2 = z(e2.activeOption, "[data-group]"), s2 = K(e2.activeOption, "[data-selectable]"), r2 && (r2 = 37 === i2.keyCode ? r2.previousSibling : r2.nextSibling) && (n2 = (o2 = r2.querySelectorAll("[data-selectable]"))[Math.min(o2.length - 1, s2)]) && e2.setActiveOption(n2);
        });
      }), de.define("remove_button", function(e2) {
        const t2 = Object.assign({ label: "&times;", title: "Remove", className: "remove", append: true }, e2);
        var i2 = this;
        if (t2.append) {
          var s2 = '<a href="javascript:void(0)" class="' + t2.className + '" tabindex="-1" title="' + Z(t2.title) + '">' + t2.label + "</a>";
          i2.hook("after", "setupTemplates", () => {
            var e3 = i2.settings.render.item;
            i2.settings.render.item = (t3, n2) => {
              var o2 = j(e3.call(i2, t3, n2)), r2 = j(s2);
              return o2.appendChild(r2), se(r2, "mousedown", (e4) => {
                ie(e4, true);
              }), se(r2, "click", (e4) => {
                i2.isLocked || (ie(e4, true), i2.isLocked || i2.shouldDelete([o2], e4) && (i2.removeItem(o2), i2.refreshOptions(false), i2.inputState()));
              }), o2;
            };
          });
        }
      }), de.define("restore_on_backspace", function(e2) {
        const t2 = this, i2 = Object.assign({ text: (e3) => e3[t2.settings.labelField] }, e2);
        t2.on("item_remove", function(e3) {
          if (t2.isFocused && "" === t2.control_input.value.trim()) {
            var s2 = t2.options[e3];
            s2 && t2.setTextboxValue(i2.text.call(t2, s2));
          }
        });
      }), de.define("virtual_scroll", function() {
        const e2 = this, t2 = e2.canLoad, i2 = e2.clearActiveOption, s2 = e2.loadCallback;
        var n2, o2, r2 = {}, l2 = false, a2 = [];
        if (e2.settings.shouldLoadMore || (e2.settings.shouldLoadMore = () => {
          if (n2.clientHeight / (n2.scrollHeight - n2.scrollTop) > 0.9)
            return true;
          if (e2.activeOption) {
            var t3 = e2.selectable();
            if (Array.from(t3).indexOf(e2.activeOption) >= t3.length - 2)
              return true;
          }
          return false;
        }), !e2.settings.firstUrl)
          throw "virtual_scroll plugin requires a firstUrl() method";
        e2.settings.sortField = [{ field: "$order" }, { field: "$score" }];
        const c2 = (t3) => !("number" == typeof e2.settings.maxOptions && n2.children.length >= e2.settings.maxOptions) && !(!(t3 in r2) || !r2[t3]), d2 = (t3, i3) => e2.items.indexOf(i3) >= 0 || a2.indexOf(i3) >= 0;
        e2.setNextUrl = (e3, t3) => {
          r2[e3] = t3;
        }, e2.getUrl = (t3) => {
          if (t3 in r2) {
            const e3 = r2[t3];
            return r2[t3] = false, e3;
          }
          return e2.clearPagination(), e2.settings.firstUrl.call(e2, t3);
        }, e2.clearPagination = () => {
          r2 = {};
        }, e2.hook("instead", "clearActiveOption", () => {
          if (!l2)
            return i2.call(e2);
        }), e2.hook("instead", "canLoad", (i3) => i3 in r2 ? c2(i3) : t2.call(e2, i3)), e2.hook("instead", "loadCallback", (t3, i3) => {
          if (l2) {
            if (o2) {
              const i4 = t3[0];
              void 0 !== i4 && (o2.dataset.value = i4[e2.settings.valueField]);
            }
          } else
            e2.clearOptions(d2);
          s2.call(e2, t3, i3), l2 = false;
        }), e2.hook("after", "refreshOptions", () => {
          const t3 = e2.lastValue;
          var i3;
          c2(t3) ? (i3 = e2.render("loading_more", { query: t3 })) && (i3.setAttribute("data-selectable", ""), o2 = i3) : t3 in r2 && !n2.querySelector(".no-results") && (i3 = e2.render("no_more_results", { query: t3 })), i3 && (D(i3, e2.settings.optionClass), n2.append(i3));
        }), e2.on("initialize", () => {
          a2 = Object.keys(e2.options), n2 = e2.dropdown_content, e2.settings.render = Object.assign({}, { loading_more: () => '<div class="loading-more-results">Loading more results ... </div>', no_more_results: () => '<div class="no-more-results">No more results</div>' }, e2.settings.render), n2.addEventListener("scroll", () => {
            e2.settings.shouldLoadMore.call(e2) && c2(e2.lastValue) && (l2 || (l2 = true, e2.load.call(e2, e2.lastValue)));
          });
        });
      }), de;
    });
  }
});
export default require_tom_select_complete_min();
//# sourceMappingURL=tom-select_dist_js_tom-select__complete__min.js.map
